#!/usr/bin/env bash

. `printenv COMMON || echo /usr/local/etc/hephaestus/common` || exit 1

PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

usage () { echo "usage: $0 commitfile" ; }
usageerr () { usage >&2 ; return 1 ; }

# Takes a single argument - a filename representing a commit. This file should
# have been set up by schedule_build.
[ $# -eq 1 ] || usageerr

generatemail () {
	AUTHORMAIL="`finger -m -p $AUTHOR | head -n1 | cut -d: -f3- | cut -b2-` <$AUTHOR@svn.research.sys>"
	LASTREV="$(($REV - 1))"
	TITLE="`echo [$REPONAME-$REV] \"$MSG\" | $XML unesc | tr \\\n \\  | cut -b-70`"
	# Do not echo input ($MSG, $TITLE especially) using escapes (-e)! We
	# want to preserve the input precisely.
	echo "From: $AUTHORMAIL"
	echo "Subject: $TITLE"
	echo -e "Content-Type: text/plain; charset=utf-8\n"
	echo "$MSG" | "$XML" unesc | fmt -w76 -
	echo -e "\nhttp://svn.research.sys/websvn/listing.php?repname=$REPONAME&rev=$REV&sc=1\nhttp://svn.research.sys/cgi-bin/viewvc.cgi?view=rev&root=$REPONAME&revision=$REV\n"
	svn diff file://$REPOS@$LASTREV file://$REPOS@$REV
	echo -e "\n-- \ngenerated by $0 on $HOSTNAME\nreport bugs to nick black <dank@qemfd.net>"
}

# Arguments: itinerary file, scratch file, msgid, path, image
add_build () {
	[ $# -eq 5 ] || { echo "Param err: expected itinerary, scratchfile, msgid, path, image, got $@" >&2 ; return 1 ; }
	"$XML" ed -s "//commit[inreplyto='$3']" -t elem -n build -v "" \
	 -s "//commit[inreplyto='$3']/build[last()]" -t elem -n path -v "$4" \
	 -s "//commit[inreplyto='$3']/build[last()]" -t elem -n image -v "$5" "$1" > "$2"
	"$XML" val -e -r "$SCHEMA_ITINERARY" "$2" > /dev/null
	cat < "$2" > "$1"
}

schedule_autobuild_locked () {
	local idx
	local i
	[ ${#BUILDPATHS[@]} -eq ${#BUILDIMAGES[@]} ] || { echo "Buildpaths didn't match up with images: ( ${BUILDPATHS[@]} ) vs ( ${BUILDIMAGES[@]} )" >&2 ; return 1 ; }
	"$XML" ed -s "//hephaestus" -t elem -n commit -v "" \
	 -s "//commit[last()]" -t elem -n repository -v "$REPOS" \
	 -s "//commit[last()]" -t elem -n revision -v "$REV" \
	 -s "//commit[last()]" -t elem -n schedtime -v "`date '+%Y-%m-%dT%H:%M:%S'`" \
	 -s "//commit[last()]" -t elem -n inreplyto -v "$MSGID" \
	 -s "//commit[last()]" -t elem -n author -v "$AUTHOR" \
	 -s "//commit[last()]" -t elem -n log -v "$MSG" \
	 < "$ITINERARY" > "$TMP"
	BUILDTMP="`mktemp -t \`basename $0\`.XXXXXX`"
	for idx in $(seq 0 $((${#BUILDPATHS[@]} - 1))) ; do
		for i in `echo ${BUILDIMAGES[$idx]} | tr , \ ` ; do
			add_build "$TMP" "$BUILDTMP" "$MSGID" "${BUILDPATHS[$idx]}" "$i" || { rm -f "$BUILDTMP" ; return 1 ; }
		done
	done
	rm -f "$BUILDTMP"
	"$XML" val -e -r "$SCHEMA_ITINERARY" "$TMP"
	mv "$TMP" "$ITINERARY"
}

schedule_autobuild () {
	spin_on_dotlock "$ITINERARY"
	schedule_autobuild_locked || { unlock_dotlock "$ITINERARY" ; return 1 ; }
	unlock_dotlock "$ITINERARY"
}

# Arguments: Subversion URI, revision.
# Input: a series of absolute pathname components to use with the URI
# Output: those pathname components which were affected by this revision
filter_unaffected_uris () {
	local URIS
	local URI
	[ $# -eq 2 ] || { echo "Param err: expected URI, rev, got $@" >&2 ; return 1 ; }
	while read URIS ; do
		for URI in $URIS ; do
			if svn diff --xml --summarize -c$2 $1 | "$XML" sel -t -v //path | grep "^$1$URI" > /dev/null ; then
				echo "$URI"
			elif [ "$URI" = "/" ] ; then
				# "/" is always affected, but toplevel property
				# changes aren't listed with a trailing slash
				echo "$URI"
			else
				echo "$URI wasn't affected, filtering" >&2
			fi
		done
	done
}

# Arguments: Subversion URI, revision.
# Input: none.
# Output: absolute branch root paths which were created or modified in that
#  revision (branch roots which were deleted will not be listed). A 
#  repository's branch roots are defined as either:
#   all directories within a toplevel directory branches/, should it exist,
#   all directories within a toplevel directory tags/, should it exist,
#    along with a toplevel directory named trunk/, should it exist, OR
#   the toplevel directory / if there would otherwise be no branch roots.
get_build_paths () {
	[ $# -eq 2 ] || { echo "Param err: expected URI, rev, got $@" >&2 ; return 1 ; }
	if svn ls --xml "$1/branches@$2" > /dev/null 2>&1 ; then
		svn ls --xml "$1/branches@$2" | "$XML" sel -t -m "//entry[@kind='dir']" -o /branches/ -v name -n 2> /dev/null
	fi
	if svn ls --xml "$1/tags@$2" > /dev/null 2>&1 ; then
		svn ls --xml "$1/tags@$2" | "$XML" sel -t -m "//entry[@kind='dir']" -o /tags/ -v name -n 2> /dev/null
	fi
	svn ls --xml "$1@$2" | "$XML" sel -t -m "//entry[@kind='dir']" -o / -v name -n | grep '^/trunk$' 2> /dev/null || echo '/'
}

# Arguments: Repository name, one or more build paths
get_build_images () {
	[ $# -ge 2 ] || { echo "Param err: expected reponame, buildpath(s), got $@" >&2 ; return 1 ; }
	local REPONAME="$1"
	local IMAGECONF=/usr/local/etc/hephaestus/images
	local BUILDPATH
	shift
	for BUILDPATH in "$@" ; do
		if grep "^$REPONAME:$BUILDPATH:" < "$IMAGECONF" > /dev/null 2>&1 ; then
			grep "=`grep \"^$REPONAME:$BUILDPATH:\" < \"$IMAGECONF\" | cut -d: -f3-`\$" < "$IMAGECONF" | cut -d= -f1
		else
			# if none's specified, use the first one listed
			grep ".*=.*" < "$IMAGECONF" | head -n1 | cut -d= -f1
		fi
	done
}

# Takes two arguments - a repository name and a revision.
prep_build () {
	[ $# -eq 2 ] || { echo "Param err: expected repo, rev, got $@" >&2 ; return 1 ; }
	REPONAME="$1"
	REV="$2"
	REPOS="/svn/$REPONAME"
	MSG="`svn log --xml -r$REV file://$REPOS | "$XML" sel -t -v //msg | "$XML" esc`"
	# FIXME horrible hardcoding here!
	NEWSGROUPPREFIX=`find -H $SNROOT -maxdepth 1 -iname sys\*.$REPONAME | cut -d/ -f7- | cut -d. -f-3`.
	BUILDPATHS=( `get_build_paths file://$REPOS $REV | filter_unaffected_uris file://$REPOS $REV` )
	AUTHOR="`svn log --xml -r$REV file://$REPOS | "$XML" sel -t -v //author`"
	MSGID=`generatemail 2>&1 | snmail -v -s -c "$REPONAME" $NEWSGROUPPREFIX | cut -d \< -f2- | cut -d \> -f1`
	if [ -z "$MSGID" -o -z "$AUTHOR" ] ; then
		echo "Need an author and a msgid currently, won't build $REPONAME $REV" >&2
	elif [ "${#BUILDPATHS[@]}" -ne 0 ] ; then
		BUILDIMAGES=( `get_build_images $REPONAME ${BUILDPATHS[@]}` )
		echo "${BUILDIMAGES[@]}"
		TMP=`mktemp -t \`basename $0\`.XXXXXX`
		chmod 0644 "$TMP"
		# TMP is removed on successful schedule_autobuild return
		schedule_autobuild || { rm -f "$TMP" ; return 1 ; }
	else
		echo "No paths affected for $REPONAME $REV" >&2
	fi
}

prep_build "`basename $1 | cut -d. -f1`" "`basename $1 | cut -d. -f2`"
COMMITFILE="$HEPHDIR/commits/$1"
echo -n "Removing $COMMITFILE..."
rm "$COMMITFILE"
echo "done."
